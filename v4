import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import CreateNewApp from './CreateNewApp';
import { Service } from '../../../Root/import';
import axios from 'axios';
import { toast } from 'react-toastify';

jest.mock('../../../Root/import', () => ({
  Service: { postService: jest.fn() },
}));

jest.mock('axios');
jest.mock('react-toastify', () => ({
  toast: { warn: jest.fn(), success: jest.fn(), error: jest.fn() },
  ToastContainer: () => <div />,
}));

describe('CreateNewApp Component', () => {
  const onBackMock = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders all form fields and buttons', () => {
    render(<CreateNewApp onBack={onBackMock} />);

    // Header
    expect(screen.getByText(/Add New Application/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Submit/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Save/i })).toBeInTheDocument();

    // Text fields
    ['Application ID', 'ITAM Name', 'Application Name', 'Description', 'App Owner', 'Application Dev DL'].forEach(label => {
      expect(screen.getByLabelText(label)).toBeInTheDocument();
    });

    // Date time fields
    expect(screen.getByLabelText('Downtime Start')).toBeInTheDocument();
    expect(screen.getByLabelText('Downtime End')).toBeInTheDocument();

    // Select
    expect(screen.getByLabelText('Recurring Downtime')).toBeInTheDocument();
  });

  test('calls onBack when back button is clicked', () => {
    render(<CreateNewApp onBack={onBackMock} />);
    const backButton = screen.getByRole('button', { name: /arrow back icon/i });
    userEvent.click(backButton);
    expect(onBackMock).toHaveBeenCalled();
  });

  test('shows warning toast if required fields are missing', async () => {
    render(<CreateNewApp onBack={onBackMock} />);
    const submitBtn = screen.getByRole('button', { name: /Submit/i });
    userEvent.click(submitBtn);

    await waitFor(() => {
      expect(toast.warn).toHaveBeenCalledWith(
        'Please fill all required fields before submitting.',
        expect.objectContaining({ position: 'top-right', autoClose: 3000 })
      );
    });
  });

  test('submits form successfully with valid data', async () => {
    (Service.postService as jest.Mock).mockResolvedValue({ status: 201 });

    render(<CreateNewApp onBack={onBackMock} />);

    // Fill fields
    const fillField = (label: string, value: string) => {
      const input = screen.getByLabelText(label) as HTMLInputElement;
      userEvent.type(input, value);
      expect(input.value).toBe(value);
    };

    fillField('Application ID', '123');
    fillField('ITAM Name', 'ITAM');
    fillField('Application Name', 'MyApp');
    fillField('Description', 'Desc');
    fillField('App Owner', 'Owner');
    fillField('Application Dev DL', 'dev@dl.com');
    fillField('PSS DL', 'pss@dl.com');

    // Downtime
    const start = screen.getByLabelText('Downtime Start') as HTMLInputElement;
    userEvent.type(start, '2025-05-21T10:00');
    expect(start.value).toBe('2025-05-21T10:00');

    const end = screen.getByLabelText('Downtime End') as HTMLInputElement;
    userEvent.type(end, '2025-05-21T12:00');
    expect(end.value).toBe('2025-05-21T12:00');

    // Select recurring downtime
    const select = screen.getByLabelText('Recurring Downtime');
    userEvent.click(select);
    const optionYes = screen.getByRole('option', { name: 'Yes' });
    userEvent.click(optionYes);
    expect(select).toHaveTextContent('Yes');

    // Submit
    const submitBtn = screen.getByRole('button', { name: /Submit/i });
    userEvent.click(submitBtn);

    await waitFor(() => {
      expect(Service.postService).toHaveBeenCalledWith(
        '/fmces/p80/v1/data-policy/create',
        expect.any(Object)
      );
      expect(toast.success).toHaveBeenCalledWith('App created successfully!');
      expect(onBackMock).toHaveBeenCalled();
    });
  });

  test('handles submission error', async () => {
    (Service.postService as jest.Mock).mockRejectedValue(new Error('fail'));

    render(<CreateNewApp onBack={onBackMock} />);

    // Fill minimal required fields to pass validation
    ['Application ID', 'ITAM Name', 'Application Name', 'Description', 'App Owner', 'Application Dev DL', 'PSS DL'].forEach(label => {
      const input = screen.getByLabelText(label) as HTMLInputElement;
      userEvent.type(input, 'x');
    });
    const select = screen.getByLabelText('Recurring Downtime');
    userEvent.click(select);
    userEvent.click(screen.getByRole('option', { name: 'Yes' }));

    userEvent.click(screen.getByRole('button', { name: /Submit/i }));

    await waitFor(() => {
      expect(toast.error).toHaveBeenCalledWith('Failed to create App.', expect.objectContaining({ position: 'top-right', autoClose: 3000 }));
    });
  });
});
