test('displays error state when API fails', async () => {
  const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});
  
  // Clear previous mocks
  mockedAxios.get.mockReset();
  // Mock rejection for applications endpoint only
  mockedAxios.get.mockRejectedValueOnce(new Error('API Error'));
  
  render(<AppManagementview {...mockProps} />);
  
  await waitFor(() => {
    expect(screen.getByText(/error fetching applications/i)).toBeInTheDocument();
  });
  
  consoleError.mockRestore();
});


test('displays applications data correctly', async () => {
  render(<AppManagementview {...mockProps} />);
  
  // Wait for table rendering
  const row = await screen.findByRole('row', {
    name: /Test App/i
  });

  // Verify row content
  expect(within(row).getByText('Test App')).toBeInTheDocument();
  expect(within(row).getByText('Enabled')).toBeInTheDocument();
  expect(within(row).getByText('2 Features')).toBeInTheDocument();
  expect(within(row).getByText('3 User Actions')).toBeInTheDocument();
});



test('shows features grouped by application', async () => {
  render(<AppManagementview {...mockProps} />);
  
  // Switch to Features tab
  fireEvent.click(await screen.findByText('Features'));
  
  // Wait for features data to load
  await waitFor(() => {
    expect(screen.getByText('1 - Test App')).toBeInTheDocument(); // Use app ID from mock data
  });

  // Verify feature details
  const featureRow = await screen.findByRole('row', {
    name: /Test Feature/i
  });
  
  expect(within(featureRow).getByText('Test Feature')).toBeInTheDocument();
  expect(within(featureRow).getByText('Feature Desc')).toBeInTheDocument();
});
