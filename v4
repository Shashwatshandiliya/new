import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import DeleteExistingApp from './DeleteExistingApp';
import axios from 'axios';
import { ToastContainer } from 'react-toastify';
import '@testing-library/jest-dom';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('DeleteExistingApp', () => {
  const mockOnBack = jest.fn();
  const mockAppId = '123';
  const mockAppDetails = {
    appUID: '456',
    appID: 'TEST123',
    itamName: 'ITAM1',
    appName: 'Test App',
    appDesc: 'Test Description',
    appOwner: 'Owner',
    contactDL: 'dl@test.com',
    downtimeStart: '2023-01-01T00:00',
    downtimeEnd: '2023-01-01T01:00',
    isActive: true,
    isRecurringDowntime: true,
    pssDL: 'pss@test.com'
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockedAxios.get.mockResolvedValue({ data: [mockAppDetails] });
    mockedAxios.delete.mockResolvedValue({ status: 200 });
  });

  test('renders all form elements with disabled state', async () => {
    render(<DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />);
    
    await waitFor(() => {
      expect(screen.getByLabelText('Application ID')).toBeDisabled();
      expect(screen.getByLabelText('ITAM Name')).toBeDisabled();
      expect(screen.getByLabelText('Recurring Downtime')).toBeDisabled();
    });
  });

  test('fetches and displays app details on mount', async () => {
    render(<DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />);
    
    await waitFor(() => {
      expect(mockedAxios.get).toHaveBeenCalledWith(
        `http://uklvauems02a.uk.standardchartered.com:8083/fmces/v1/application/findByAppItamId/${mockAppId}`
      );
      expect(screen.getByDisplayValue('TEST123')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Test App')).toBeInTheDocument();
    });
  });

  test('opens confirmation drawer when delete button is clicked', async () => {
    render(
      <>
        <ToastContainer />
        <DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />
      </>
    );

    fireEvent.click(screen.getByText('Delete'));
    expect(screen.getByText('Delete App')).toBeInTheDocument();
  });

  test('successfully deletes app and navigates back', async () => {
    render(
      <>
        <ToastContainer />
        <DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />
      </>
    );

    // Open drawer
    fireEvent.click(screen.getByText('Delete'));
    
    // Confirm delete
    fireEvent.click(screen.getByText('Delete'));

    await waitFor(() => {
      expect(mockedAxios.delete).toHaveBeenCalledWith(
        `http://uklvauems02a.uk.standardchartered.com:8083/fmces/v1/application/deleteById/${mockAppDetails.appUID}`
      );
    });

    await waitFor(() => {
      expect(screen.getByText('App deleted successfully!')).toBeInTheDocument();
    });

    act(() => {
      jest.advanceTimersByTime(1000);
    });

    expect(mockOnBack).toHaveBeenCalled();
  });

  test('handles delete error', async () => {
    mockedAxios.delete.mockRejectedValue(new Error('API Error'));
    
    render(
      <>
        <ToastContainer />
        <DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />
      </>
    );

    fireEvent.click(screen.getByText('Delete'));
    fireEvent.click(screen.getByText('Delete'));

    await waitFor(() => {
      expect(screen.getByText('Failed to submit delete. Please try again.')).toBeInTheDocument();
    });
  });

  test('handles empty response from fetch', async () => {
    mockedAxios.get.mockResolvedValue({ data: [] });
    
    render(<DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />);
    
    await waitFor(() => {
      expect(screen.queryByDisplayValue('TEST123')).not.toBeInTheDocument();
    });
  });

  test('updates recurring downtime select correctly', async () => {
    mockedAxios.get.mockResolvedValue({ 
      data: [{ ...mockAppDetails, isRecurringDowntime: false }] 
    });
    
    render(<DeleteExistingApp appId={mockAppId} onBack={mockOnBack} />);
    
    await waitFor(() => {
      expect(screen.getByText('No')).toBeInTheDocument();
    });
  });
});
