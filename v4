test('displays applications data correctly', async () => {
  // Ensure fresh mock data
  mockedAxios.get.mockResolvedValueOnce({ data: [{
    ...mockAppsData[0],
    appID: '1', // Match expected string type
    totalNumberOfFeatures: 2,
    totalNumberOfActions: 3
  }]});

  render(<AppManagementview {...mockProps} />);
  
  // Wait for data to load
  await waitFor(() => {
    const row = screen.getByRole('row', {
      name: /Test App/i
    });
    
    // Verify exact cell content
    expect(within(row).getByRole('cell', { name: 'Test App' })).toBeInTheDocument();
    expect(within(row).getByRole('cell', { name: '1' })).toBeInTheDocument();
    expect(within(row).getByRole('cell', { name: 'Enabled' })).toBeInTheDocument();
    expect(within(row).getByRole('cell', { name: '2' })).toBeInTheDocument(); // Features count
    expect(within(row).getByRole('cell', { name: '3' })).toBeInTheDocument(); // Actions count
  });
});



test('displays error state when API fails', async () => {
  // Clear previous mocks
  mockedAxios.get.mockReset();
  
  // Mock specific endpoint failure
  mockedAxios.get.mockImplementation(url => {
    if (url.includes('applicationsWithCountOfFeaturesAndActions')) {
      return Promise.reject(new Error('API Error'));
    }
    return Promise.resolve({ data: [] });
  });

  render(<AppManagementview {...mockProps} />);
  
  await waitFor(() => {
    expect(screen.getByTestId('error-message')).toHaveTextContent(
      'Error fetching applications'
    );
  });
});
